#include<bits/stdc++.h>
using namespace std;

void reversestack(stack<int>st)
{
    
}

void solve(stack<int>&st, int num)
{
    if(st.empty())
    {
        st.push(num);
        return ;
    }
    
    int el=st.top();
    st.pop();
    
    solve(st, num)
    st.push(el);
}
stack<int>insertinbottomrec(stack<int>st, int num)
{
    solve(st, num);
    return st;
}
stack<int> insertinbottom(stack<int>st, int num)
{
    stack<int>temp;
    while(!st.empty())
    {
        temp.push(st.top());
        st.pop();
    }
    
    st.push(num);
    
    while(!temp.empty())
    {
        st.push(temp.top());
        temp.pop();
    }
    return st;
}

void solve(stack<int>&st, int count, int n)
{
    if(count==n/2)
    {
        st.pop();
        return ;
    }
    
    int num=st.top();
    st.pop();
    
    solve(st, count+1, n);
    st.push(num);
}
void deletemiddle(stack<int>st, int n)
{
    int count=0;
    solve(st, count, n);
}


bool isvalidpar(string s)
{
    stack<char>st;
    for(int i=0; i<s.length(); i++)
    {
        char ch=s[i];
        if(ch=='(' || ch=='{' || ch=='[')
        {
            st.push(ch);
        }
        else 
        {
            if(!st.empty())
            {
                char top=st.top();
                if((ch==')' && top=='(') || (ch=='}' && top=='{') || (ch==']' && top=='['))
                {
                    st.pop();
                }
                else 
                {
                    return false;
                }
            }
            else 
            {
                return false;
            }
        }
    }
    
    if(st.empty())
    return true;
    
    return false;
}

string reversest(string s)
{
    stack<char>st;
    for(int i=0; i<s.length(); i++)
    {
        st.push(s[i]);
    }
    
    string ans;
    while(!st.empty())
    {
        ans+=st.top();
        st.pop();
    }
    return ans;
}

//------------------------------------------------------------------------------

int threesum(int arr[], int n, int target)
{
    for(int i=0; i<n; i++)
    {
        for(int j=i+1; j<n; j++)
        {
            for(int k=j+1; k<n; k++)
            {
                if(arr[i]+arr[j]+arr[k]==target)
                {
                    return 1;
                }
            }
        }
    }
    
    vector<vector<int>>ans;
    sort(arr, arr+n);
    for(int i=0; i<n-1; i++)
    {
        if(i>0 && arr[i]==arr[i-1])
        continue; 
        
        int start=i+1;
        int end=n-1;
        int sum=target-arr[i];
        
        while(start<end)
        {
            
        }
    }
}

int twosum(int arr[], int n, int target)
{
    for(int i=0; i<n; i++)
    {
        for(int j=i+1; j<n; j++)
        {
            if(arr[i]+arr[j]==target)
            {
                return 1;
            }
        }
    }
    
    int start=0;
    int end=n-1;
    while(start<=end)
    {
        if(arr[start]+arr[end]==target)
        {
            return {start+1, end+1};
        }
        else if(arr[start]+arr[end]<target)
        {
            start++;
        }
        else 
        {
            end--;
        }
    }
    
    unordered_map<int,int>mp;
    vector<int>ans;
    for(int i=0; i<n; i++)
    {
        if(mp.find(target-arr[i])!=mp.end())
        {
            ans.push_back(mp[target-arr[i]]);
            ans.push_back(i);
            return ans;
        }
        
        mp[arr[i]]=i;
    }
    return ans;
}

int thirdlargest(int arr[], int n)
{
    int a=INT_MIN;
    int b=INT_MIN;
    int c=INT_MIN;
    int flage=0;
    for(int i=0; i<n; i++)
    {
        a=max(a, arr[i]);
    }
    
    for(int i=0; i<n; i++)
    {
        if(a!=arr[i])
        {
            b=max(b, arr[i]);
        }
    }
    
    for(int i=0; i<n; i++)
    {
        if(arr[i]!=a && arr[i]!=b)
        {
            c=max(c, arr[i]);
            flage=1;
            break;
        }
    }
    
    if(flage)
    return c;
    
    return a;
}

int secondlargest(int arr[], int n)
{
    int largest=-1;
    int sec=-1;
    for(int i=0; i<n; i++)
    {
        if(arr[i]>largest)
        {
            sec=largest;
            largest=arr[i];
        }
        else if(arr[i]<largest && arr[i]>sec)
        {
            sec=arr[i];
        }
    }
    return sec;
}

int maximumel(int arr[], int n)
{
    int maxi=INT_MIN;
    for(int i=0; i<n; i++)
    {
        if(arr[i]>maxi)
        {
            maxi=arr[i];
        }
    }
    return maxi;
}

//------------------------------------------------------------------------------ 


//some doubt 
ListNode*intersectionopt(ListNode*head1, ListNode*head2)
{
    if(head2==NULL || head1==NULL)
    return NULL;
    
    ListNode*temp1=head1;
    ListNode*temp2=head2;
    while(true)
    {
        if(temp1==NULL)
        {
            temp1=head2;
        }
        else
        {
            temp1=temp1->next;
        }
        
        if(temp2==NULL)
        {
            temp2=head1;
        }
        else 
        {
            temp2=temp2->next;
        }
    }
    return temp1;
}
ListNode*intersection(ListNode*head1, ListNode*head2)
{
    if(head2==NULL || head1==NULL)
    return NULL;
    
    int len1=findlength(head1);
    int len2=findlength(head2);
    
    ListNode*temp1=head1;
    ListNode*temp2=head2;
    if(len2<len1)
    {
        while(len1-len2)
        {
            temp1=temp1->next;
        }
    }
    else 
    {
        while(len2-len1)
        {
            temp2=temp2->next;
        }
    }
    
    while(temp2!=temp1)
    {
        temp1=temp1->next;
        temp2=temp2->next;
    }
    return temp1;
}

ListNode*removeduplicateopt(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    ListNode*temp=head;
    while(temp->next!=NULL)
    {
        if(temp->val==temp->next->val)
        {
            ListNode*del=temp->next;
            temp->next=temp->next->next;
            delete del;
        }
        else 
        {
            temp=temp->next;
        }
    }
    return head;
}
ListNode*removeduplicate(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    unordered_set<int>st;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        st.push(temp->val);
        temp=temp->next;
    }
    
    temp=head;
    for(auto it : st)
    {
        temp->val=it;
        temp=temp->next;
    }
    
    temp=head;
    int count=st.size();
    while(count--)
    {
        temp=temp->next;
    }
    temp->next=NULL;
    
    return head;
}

TreeNode*convertlisttobst(ListNode*head)
{
    if(head==NULL)
    return NULL;
    
    if(head->next==NULL)
    return new TreeNode(head->val); 
    
    ListNode*slow=head;
    ListNode*fast=head;
    ListNode*pre=NULL;
    while(fast!=NULL && fast->next!=NULL)
    {
        pre=slow;
        slow=slow->next;
        fast=fast->next->next;
    }
    
    TreeNode*root=new TreeNode(slow->val);
    pre->next=NULL;
    
    root->left=convertlisttobst(head);
    root->right=convertlisttobst(slow->next);
    
    return root;
}
TreeNode*solve(vector<int>&arr int start, int end)
{
    if(start>end)
    return ;
    
    int mid=start+(end-start)/2;
    
    TreeNode*root=new TreeNode(arr[mid]);
    root->left=solve(arr, start, mid);
    root->right=solve(arr, mid+1, end);
    
    return root;
}
TreeNode*convertlisttobst(ListNode*head)
{
    if(head==NULL)
    return NULL;
    
    if(head->next==NULL)
    return new TreeNode(head->val);
    
    vector<int>arr;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        arr.push_back(temp->val);
        temp=temp->next;
    }
    
    return solve(arr, 0, arr.size()-1);
}

bool palindromerev(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return true;
    
    ListNode*slow=head;
    ListNode*fast=head;
    ListNode*pre=NULL;
    while(fast!=NULL && fast->next!=NULL)
    {
        pre=slow;
        slow=slow->next;
        fast=fast->next;
    }
    
    pre->next=NULL;
    ListNode*first=head;
    ListNode*second=reversest(slow->next);
    while(second!=NULL)
    {
        if(first->val!=second->val)
        return false;
        
        first=first->next;
        second=second->next;
    }
    return true;
}
bool checkplaindrome(vector<int>&arr)
{
    int n=arr.size();
    int start=0;
    int end=n-1;
    while(start<=end)
    {
        if(arr[start]!=arr[end])
        return false;
        
        start++;
        end--;
    }
    return true;
}
bool palindrome(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return true;
    
    vector<int>arr;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        arr.push_back(temp->val);
        temp=temp->next;
    }
    
    bool ans=checkplaindrome(arr);
    
    return ans;
}
bool palindrome(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return true;
    
    stack<int>st;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        st.push(temp->val);
        temp=temp->next;
    }
    
    temp=head;
    while(temp!=NULL)
    {
        if(temp->val!=st.top())
        return false;
        
        temp=temp->next;
        st.pop();
    }
    
    return true;
}

ListNode*sort012opt(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    ListNode*zeroh=new ListNode(0);
    ListNode*zerot=zeroh;
    ListNode*oneh=new ListNode(0);
    ListNode*onet=oneh;
    ListNode*twoh=new ListNode(0);
    ListNode*twot=twoh;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        if(temp->val==0)
        {
            zerot->next=temp;
            temp=temp->next;
            zerot=zerot->next;
        }
        else if(temp->val==1)
        {
            onet->next=temp;
            temp=temp->next;
            onet=onet->next;
        }
        else 
        {
            twot->next=temp;
            temp=temp->next;
            twot=twot->next;
        }
    }
    
    zerot->next=oneh->next!=NULL :? oneh->next : twoh->next;
    onet->next=twoh->next;
    twot->next=NULL;
    head=zeroh->next;
    
    delete (zeroh);
    delete (oneh);
    delete (twoh);
    
    return head;
}
ListNode*sort012(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    int count0=0;
    int count1=0;
    int count2=0;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        if(temp->val==0)
        {
            count0++;
        }
        else if(temp->val==1)
        {
            count1++;
        }
        else 
        {
            count2++;
        }
    }
    
    temp=head;
    while(count0--)
    {
        temp->val=0;
        temp=temp->next;
    }
    
    while(count1--)
    {
        temp->val=0;
        temp=temp->next;
    }
    
    while(count2--)
    {
        temp->val=0;
        temp=temp->next;
    }
    return head;
}

ListNode*startingpointopt(ListNode*head)
{
    if(head==NULL)
    return NULL;
    
    ListNode*slow=head;
    ListNode*fast=head;
    while(fast!=NULL && fast->next!=NULL)
    {
        slow=slow->next;
        fast=fast->next->next;
        if(slow==fast)
        break;
    }
    
    slow=head;
    while(slow!=fast)
    {
        slow=slow->next;
        fast=fast->next;
    }
    return slow;
}
ListNode*startingpoint(ListNode*head)
{
    if(head==NULL)
    return NULL;
    
    unordered_set<ListNode*>st;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        if(st.find(temp)!=st.end())
        return temp;
        
        st.insert(temp);
        temp=temp->next;
    }
    return NULL;
}

bool isloopopt(ListNode*head)
{
    if(head==NULL)
    return true;
    
    ListNode*slow=head;
    ListNode*fast=head;
    while(fast!=NULL && fast->next!=NULL)
    {
        slow=slow->next;
        fast=fast->next->next;
        if(slow==fast)
        return true;
    }
    return false;
}
bool isloop(ListNode*head)
{
    if(head==NULL)
    return true;
    
    unordered_set<ListNode*>st;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        if(st.find(temp)!=st.end())
        return true;
        
        st.insert(temp);
        temp=temp->next;
    }
    return false;
}

ListNode*middlenodeopt(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    ListNode*slow=head;
    ListNode*fast=head;
    while(fast!=NULL && fast->next!=NULL)
    {
        slow=slow->next;
        fast=fast->next->next;
    }
    return slow;
}
ListNode*middlenode(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    ListNode*temp=head;
    int len=0;
    while(temp!=NULL)
    {
        len++;
        temp=temp->next;
    }
    
    int half=len/2;
    temp=head;
    while(half--)
    {
        temp=temp->next;
    }
    return temp;
}

ListNode*reverseit(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    ListNode*curr=head;
    ListNode*pre=NULL;
    while(curr!=NULL)
    {
        ListNode*nextn=curr->next;
        curr->next=pre;
        pre=curr;
        curr=curr->next;
    }
    return pre;
}
ListNode*reversearr(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    vector<int>arr;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        arr.push_back(temp->val);
        temp=temp->next;
    }
    
    temp=head;
    int index=temp.size()-1;
    while(temp!=NULL)
    {
        temp->val=arr[index];
        temp=temp->next;
        index--;
    }
    return head;
}
ListNode*reversestac(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    stack<int>st;
    ListNode*temp=head;
    while(temp!=NULL)
    {
        st.push(temp->val);
        temp=temp->next;
    }
    
    temp=head;
    while(!st.empty())
    {
        temp->val=st.top();
        st.pop();
        temp=temp->next;
    }
    return head;
}
ListNode*reverserec(ListNode*head)
{
    if(head==NULL || head->next==NULL)
    return head;
    
    ListNode*newh=reverserec(head->next);
    head->next->next=head;
    head->next=NULL;
    return newh;
}








